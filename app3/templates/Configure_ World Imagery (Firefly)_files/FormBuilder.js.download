/**
 *
 * @module configure/dijit/FormBuilder
 */
define(
  [
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/_base/array",
    "dojo/_base/connect",
    "dojo/_base/json",
    "dojo/aspect",

    "dojo/dom",
    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/dom-class",
    "dojo/dom-style",

    "dojo/query",
    "dojo/on",
    "dojo/topic",
    "dojo/window",

    "dojo/Deferred",
    "dojo/promise/all",

    "dojo/i18n!configure/nls/resources",
    "dojo/text!./views/details.html",

    "dijit/registry",

    "dijit/ConfirmDialog",
    "dijit/layout/TabContainer",
    "dijit/layout/ContentPane",
    "dijit/Tooltip",
    "dijit/form/Select",

    "dijit/form/ValidationTextBox",
    "dijit/form/NumberTextBox",
    "dijit/form/CheckBox",
    "dijit/form/RadioButton",
    "dijit/form/MultiSelect",
    "dijit/form/SimpleTextarea",

    "esri/config",
    "esri/basemaps",
    "esri/lang",
    "esri/arcgis/utils",

    "esri/layers/FeatureLayer",
    "esri/layers/ArcGISDynamicMapServiceLayer",
    "esri/layers/ArcGISImageServiceLayer",
    "esri/tasks/GeometryService",
    "esri/tasks/locator",
    "esri/dijit/AppProxySettings",
    "esri/dijit/ColorPicker",

    "esri/dijit/BrowseItems",
    "configure/dijit/PlugInWebMap",
    "configure/dijit/PlugInWebScene",
    "configure/dijit/PlugInGroup",

    "configure/dijit/Tree",
    "configure/dijit/SearchConfig",
    "configure/dijit/conditionUtils",


    "dijit/Editor",
    "dijit/_Widget",
    "dijit/_TemplatedMixin",
    "dijit/form/_FormMixin",
    "dijit/_editor/plugins/TextColor",
    "dijit/_editor/plugins/FontChoice",
    "dijit/_editor/plugins/ViewSource",
    "dijit/_editor/plugins/LinkDialog"

  ],
  function (
    declare, lang, array, connect, dojoJson, aspect,
    dom, domAttr, domConstruct, domClass, domStyle,
    query, on, topic, win,
    Deferred, all,
    bundle, detailTemplate, registry,
    Dialog,
    TabContainer, ContentPane, Tooltip, Select,
    ValidationTextBox, NumberTextBox, CheckBox, RadioButton,
    MultiSelect, SimpleTextarea,
    esriConfig, esriBasemaps, esriLang, arcgisUtils,
    FeatureLayer, ArcGISDynamicMapServiceLayer, ArcGISImageServiceLayer,
    GeometryService, Locator,
    AppProxySettings, ColorPicker,
    BrowseItems, PlugInWebMap, PlugInWebScene, PlugInGroup,
    Tree, SearchConfig, utils,
    Editor, _Widget, _TemplatedMixin, _FormMixin
  ) {

    var FormBuilder = declare([_Widget, _TemplatedMixin, _FormMixin], {
      declaredClass: "configure.dijit.FormBuder",
      templateString: "<div dojoAttachPoint='containerNode'></div>",
      operationalLayers: null,
      map: null,
      selectedLayerFields: [],
      baseClass: "esriFormBuilder",
      originalItem: {},
      defaultMaxSelectHeight: "150px",
      defaultTextAreaSize: 5,
      configurationValues: {},
      hasConditions: [],
      conditionErrors: [],
      constructor: function (params, srcNodeRef) {
        lang.mixin(this, (params || {}));
        this.i18n = bundle.configure;
        if (!this.configurationSettings) {
          console.error("esri.arcgisonline.FormBuilder: please provide correct parameters in the constructor");
        }
      },
      postCreate: function () {
        this._init();
        this.inherited(arguments);
      },
      destroy: function () {
        var tooltips = this.tooltips;
        array.forEach(tooltips, "item.destroy(); delete item;");
        this.inherited(arguments);
      },
      _init: function () {
        // Add App title to Configure text
        dom.byId("configTitle").innerHTML = document.title || this.i18n.title;
        this.tooltips = [];
        this.categories = this.configurationSettings;
        // Devs may have added formatting to category title.
        // Since we use it for the 'tab' label let's strip
        // out the tags.
        array.forEach(this.categories, lang.hitch(this, function (c) {
          if (c.category) {
            c.category = esriLang.stripTags(c.category);
          }
          if (c.fields) {
            c.fields.some(lang.hitch(this, function (field) {
              if (field.type === "webmap" && field.conditions) {
                if (Array.isArray(field.conditions)) {
                  field.conditions.forEach(lang.hitch(this, function (condition) {
                    this.hasConditions.push(condition);
                  }));
                }
              }
            }));
          }
        }));

        var type = null,
          id = null;
        if (this.values.webscene) {
          type = "webscene";
          id = this.values.webscene;
        } else if (this.values.webmap) {
          type = "webmap";
          id = this.values.webmap;
        } else if (this.values.group) {
          type = "group";
          id = this.values.group;
        }

        if (!id || id === "undefined" || (lang.isArray(id) && id.length === 0)) {
          this.buildConfigurationPanel();
        } else {
          this._getItem(id, type).then(lang.hitch(this, function (testItem) {
            if (id && !lang.isArray(id) && type !== "webscene" && type !== "group") {
              this._createWebMap(id).then(lang.hitch(this, function (response) {
                this.evaluateWebMap(response).then(lang.hitch(this, function () {
                  this.buildConfigurationPanel();
                }));
              }));
            } else {
              this.buildConfigurationPanel();
            }
          }));
        }
      },
      _getItem: function (id, type) {
        var deferred = new Deferred(),
          query = null;
        try {
          if (type === "webmap" || type === "webscene") {
            var ids = id;

            if (lang.isArray(id)) {
              array.forEach(ids, function (i, index) {
                if (index === 0) {
                  ids = "id:" + i;
                } else {
                  ids += " || " + "id:" + i;
                }
              });
            } else {
              ids = "id:" + id;
            }

            if (lang.isArray(ids) && ids.length <= 0) {
              deferred.resolve();
            } else {
              query = ids;
              this.portal.queryItems({
                q: query
              }).then(lang.hitch(this, function (response) {

                if (response.results.length > 0) {
                  const item = response.results[0];
                  this.item = {
                    info: item,
                    title: item.title,
                    type: type,
                    multipleItems: response.results.length > 1 ? response.results : null
                  }
                } else {
                  this.item = {
                    info: null,
                    title: null,
                    type: null,
                    multipleItems: null
                  }
                }
                deferred.resolve(this.item);
              }));
            }
          } else if (type === "group") {
            query = "id:" + id;
            this.portal.queryGroups({
              q: query
            }, true).then(lang.hitch(this, function (groups) {
              if (groups.results.length > 0) {
                const item = groups.results[0];
                this.item = {
                  info: item,
                  title: item.title,
                  type: type,
                  multipleItems: null
                }
              }
              deferred.resolve(this.item);
            }));
          } else if (type === "basemapgroup") {
            query = "id:" + id;
            this.portal.queryGroups({
              q: query
            }, true).then(lang.hitch(this, function (groups) {
              if (groups.results.length > 0) {
                var item = groups.results[0];
                deferred.resolve(item);
              }
            }));
          }
        } catch (err) {
          deferred.resolve();
        }
        return deferred.promise;
      },
      _createWebMap: function (id) {
        var deferred = new Deferred();
        arcgisUtils.arcgisUrl = this.portal.portalUrl + "/content/items";
        var geomUrl = document.location.protocol + "//tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer";
        esriConfig.defaults.geometryService = new GeometryService(geomUrl);
        try {
          arcgisUtils.createMap(id, domConstruct.create("div"), {
            bingMapsKey: this.portal.bingKey
          }).then(lang.hitch(this, function (results) {
            this.map = results.map;
            this.item = {
              title: results.itemInfo.item.title,
              info: results.itemInfo.item,
              item: results.itemInfo.itemData,
              type: "webmap",
              multipleItems: null
            }

            this.operationalLayers = this._processLayers(results);

            deferred.resolve(results);
          }), lang.hitch(this, function (error) {
            //build the config panel even if there's an error in createMap.
            //users can then change the map.
            //reset the map title because its invalid
            console.log(error);
            this.item = {
              title: "Invalid map",
              type: "webmap"
            }

            deferred.resolve();
          }));
        } catch (err) {
          deferred.resolve();
        }
        return deferred.promise;
      },
      evaluateWebMap: function (response) {
        var deferred = new Deferred();
        utils.data = response;
        if (this.hasConditions && this.hasConditions.length && this.hasConditions.length > 0) {
          // we have at least one condition to evaluate
          utils.evalWebMapConditions(this.hasConditions);
          deferred.resolve();
        } else {
          deferred.resolve();
        }
        return deferred.promise;
      },
      updateConfigurationPanel: function (item) {
        this.item = {
          info: item,
          title: item.title,
          type: item.type,
          multipleItems: null
        }
        if (item.type === "webmap" && !lang.isArray(item.id)) {
          //update the title to be the new map title

          this._createWebMap(item.id).then(lang.hitch(this, function (response) {

            this.evaluateWebMap(response).then(lang.hitch(this, function () {

              this._updateSelectedItemDescription(item.type);
              // update app proxy list to include premium content in new web map.

              var widget = registry.byId("appProxyWidget");

              if (widget && item.id) {
                // clear all non-enabled proxies. Leave service proxies
                var proxies = [];
                array.forEach(widget.proxies, function (proxy) {
                  if (proxy.type && proxy.type === "service") {
                    proxies.push(proxy);
                  }
                  if (proxy.proxied) {
                    proxies.push(proxy);
                  }
                });
                widget.set("webmaps", [item.id]);
                widget.set("proxies", proxies);
              }
              //update the smart dropdown lists
              array.forEach(this.categories, lang.hitch(this, function (category) {
                array.some(category.fields, lang.hitch(this, function (field) {
                  if (field.type && field.type === "conditional") {
                    array.forEach(field.items, lang.hitch(this, function (item) {
                      this._updateConfigField(item);
                    }));
                  } else {
                    this._updateConfigField(field);
                  }
                }));
              }));
            }));

          }));

        } else if (item.type === "group" || item.type === "webscene" || lang.isArray(item.id)) {
          this._getItem(item.id, item.type).then(lang.hitch(this, function () {
            this._updateSelectedItemDescription(item.type);
          }));
        }
      },
      _updateConfigField: function (field) {
        if (field.type) {
          if (field.type.toLowerCase() === "layerandfieldselector") {
            //smart field needs to be updated
            this._updateSmartField(field);
          } else if (field.type.toLowerCase() === "multilayerandfieldselector") {
            this._updateTree(field);
          } else if (field.type.toLowerCase() === "search") {
            var searchConfig = registry.byId(field.fieldName + "_search");
            if (searchConfig) {

              var appValues = this.values[field.fieldName];
              var newSources = this._updateSources(appValues.sources || [], appValues);
              if (this.map) {
                array.forEach(newSources, lang.hitch(this, function (s) {
                  if (s.flayerId) {
                    s.featureLayer = this.map.getLayer(s.flayerId);
                  }
                }));
              }
              var config = {
                sources: newSources,
                activeSourceIndex: null,
                enableSearchingAll: false
              };
              searchConfig.set("config", config);
            }
          } else if (field.type === "boolean") {
            if (field.condition) {
              var hasCondition = utils.evalBooleanCondition(field.condition);
              if (hasCondition) {
                query("." + field.fieldName).removeClass("hide-condition");

              } else {
                query("." + field.fieldName).addClass("hide-condition");
              }
            }
          }
        }
      },
      buildConfigurationPanel: function () {
        var promises = [],
          tc = null;
        var createTabs = (this.categories.length > 1) ? true : false;
        if (createTabs) {
          tc = new TabContainer({
            id: "tab-container",
            doLayout: false,
            "className": "config"
          }, domConstruct.create("div"));
          domConstruct.place(tc.domNode, dom.byId("config-options"));
          domClass.add(tc.domNode, "esriFormBuilder");
        } else {
          domClass.add("config-options", "notabs");
        }
        array.forEach(this.categories, lang.hitch(this, function (category) {
          var fields = category.fields,
            fieldSet = null,
            contentPane = null;
          if (createTabs) {
            var paneParams = {
              title: category.category,
              "className": "formPane"
            };
            fieldSet = domConstruct.create("fieldSet", {
              style: "height:100%;width:100%;"
            });
            contentPane = new ContentPane(paneParams);

            tc.addChild(contentPane);
            contentPane.set("content", fieldSet);
          } else {
            fieldSet = domConstruct.create("fieldset", {}, this.containerNode);
          }

          array.forEach(fields, lang.hitch(this, function (field) {
            promises.push(this._createField(field, fieldSet).then(lang.hitch(this, function (results) {
              array.forEach(results.nodes, function (item) {
                domConstruct.place(item.domNode || item, fieldSet);
              });
              // Add line break
              if (results.type !== "paragraph" && results.fieldDijit !== null) {
                if (field.tooltip || field.type === "conditional") {
                  if (field.type !== "conditional") {
                    this._createToolTip(field, results.fieldDijit);
                  } else {

                    if (field.items) {
                      field.items.forEach(lang.hitch(this, function (field) {

                        if (field.tooltip) {
                          // Field dijit children?
                          var cp = registry.byId(results.fieldDijit.id);
                          if (cp) {
                            if (cp && cp.containerNode && cp.containerNode.children) {
                              query("[name ='" + field.fieldName + "']").forEach(lang.hitch(this, function (node) {
                                //domAttr.set(node, "title", field.tooltip);
                                var w = registry.byId(node.id);
                                if (w) {
                                  this._createToolTip(field, w);
                                }
                              }));
                            }
                          }
                        }

                      }));
                    }
                  }
                }
              }
            })));
          }));
        }));
        all(promises).then(lang.hitch(this, function (v) {
          //All fields have been created.
          if (createTabs && tc) {
            tc.startup();
            tc.resize();
            var cframe = registry.byId("centerFrame");
            if (cframe) {
              aspect.after(cframe, "resize", lang.hitch(this, function () {
                tc.resize();
              }));
            }
          }
          dom.byId("previewFrame").src = this.appUrl;
          var mainContainer = registry.byId("mainContainer");
          if (mainContainer) {
            mainContainer.resize();
            mainContainer.layout();
          }
          domClass.add(dom.byId("loader"), "hide");
          this.onSave();
        }));
      },
      _createField: function (field) {
        var deferred = new Deferred();
        var label = null,
          fieldDijit = null,
          type = (field.type && field.type.toLowerCase()) || "string";
        //For layer and field type make the label a paragraph otherwise use label
        var nodes = [];
        if (type === "boolean") {
          fieldDijit = this._createBooleanField(field);
          nodes.push(fieldDijit);

          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "conditional") {
          fieldDijit = this._createConditionalField(field).then(lang.hitch(this, function (node) {
            if (node) {
              fieldDijit = node;
              this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
              nodes.push(node);
              deferred.resolve({
                nodes: nodes,
                fieldDijit: fieldDijit,
                type: type
              });
            }
          }));

        } else if (type === "radio") {
          fieldDijit = this._createRadioButtonGroup(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          nodes.push(fieldDijit);

          if (fieldDijit.containerNode && fieldDijit.containerNode.children) {
            array.forEach(fieldDijit.containerNode.children, lang.hitch(this, function (child) {
              on(child, "change", lang.hitch(this, function (result) {
                if (result.target && result.target.value) {
                  this.onFieldChange(field.fieldName, result.target.value);
                }
              }));
            }));
          }
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "number") {
          fieldDijit = this._createNumberField(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }

          nodes.push(fieldDijit);
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "search") {
          fieldDijit = this._createSearchConfig(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }

          nodes.push(fieldDijit);
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "custom") {
          fieldDijit = field.widget;
          fieldDijit.name = field.name;
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }

          nodes.push(fieldDijit);
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "paragraph") {

          nodes.splice(0, 1, fieldDijit = this._createParagraph(field));
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "subcategory") {
          if (field.label) {
            label = this._createLabel(field, null);
            domClass.add(label, "subcategory"); // style the label
            nodes.push(label);
          }
          deferred.resolve({
            nodes: nodes,
            type: type
          });
        } else if (field.options) {
          fieldDijit = this._createOptionsField(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          nodes.push(fieldDijit);

          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }

          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type.toLowerCase() === "layerandfieldselector") {
          fieldDijit = this._createLayerField(field);
          if (fieldDijit) {
            if (field.label) {
              label = this._createLabel(field, fieldDijit.id);
              nodes.push(label);
            }
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
            nodes.push(fieldDijit);
            deferred.resolve({
              nodes: nodes,
              fieldDijit: fieldDijit,
              type: type
            });
          } else {
            deferred.resolve();
          }
        } else if (type === "multilayerandfieldselector") {
          this._createMultiLayerField(field).then(lang.hitch(this, function (node) {
            if (node) {
              fieldDijit = node;
              if (field.label) {
                label = this._createLabel(field, fieldDijit.id);
                nodes.push(label);
              }
              this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));

              nodes.push(node);
              deferred.resolve({
                nodes: nodes,
                fieldDijit: fieldDijit,
                type: type
              });
            }
          }));
        } else if (type === "webmap" || type === "group" || type === "webscene") {

          nodes.push(this._buildItemDetails(type, field));
          nodes.push(fieldDijit = this._buildIdDialog(type, field));
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          nodes.push(domConstruct.create("br"));
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "basemapgroup") {
          var titleNode = domConstruct.create("span", {
            id: field.fieldName + "basemapgroup",
            style: "font-weight:500;font-style:normal;font-size:1.17em;margin-left:1em;"
          });
          nodes.push(fieldDijit = this._buildBasemapDialog(field, titleNode.id));

          if (this.values[field.fieldName]) {
            this._getItem(this.values[field.fieldName], "basemapgroup").then(function (item) {
              titleNode.innerHTML = item.title;
            });
          }
          nodes.push(titleNode);
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          nodes.push(domConstruct.create("br"));
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "basemaps") {
          fieldDijit = this._buildBasemapList(type, field);
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          nodes.push(fieldDijit);
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "scaleList" || type === "scalelist") {
          nodes.push(fieldDijit = this._buildScaleList(type, field));
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          nodes.push(fieldDijit);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "color") {
          fieldDijit = this._createColor(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          nodes.push(fieldDijit);

          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        } else if (type === "appproxies") {
          fieldDijit = this._createProxyWidget(field);
          var myContainer = domConstruct.create("div", {
            "id": "proxyContainer"
          });

          var premiumContentText = esriLang.substitute({
            "shield": "<img src='js/esri/dijit/img/PremiumContentUserCredit16.png' alt='" + this.i18n.premiumContent.title + "'/>"
          }, this.i18n.premiumContent.label);
          domConstruct.create("p", {
            innerHTML: premiumContentText
          }, myContainer);
          nodes.push(myContainer);
          nodes.push(fieldDijit);

          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });

        } else {
          fieldDijit = this._createStringField(field);
          if (field.label) {
            label = this._createLabel(field, fieldDijit.id);
            nodes.push(label);
          }
          if (domClass.contains(fieldDijit.domNode, "esriFormBuilderRichTextField")) {
            var editBtn = domConstruct.create("button", {
              type: "button",
              className: "edit-btn esri-icon-edit",
              innerHTML: this.i18n.categories.edit,
              click: lang.hitch(fieldDijit, this._updateEditorText)
            });

            // Populate text in edit mode 

            var content = this.values[field.fieldName] || field.tooltip || "";

            var editSpan = domConstruct.create("span", {
              className: "edit-span",
              id: "span_" + fieldDijit.id,
              innerHTML: content + "&#8206;",
              click: lang.hitch(fieldDijit, this._updateEditorText)
            });
            nodes.push(editBtn);
            nodes.push(editSpan);
            domClass.add(dom.byId(fieldDijit.domNode), "hide");
            // Added so the save button is enabled when details info is modified.
            this.connect(fieldDijit, "onKeyUp", lang.hitch(this, "onFieldChange", fieldDijit.name));

          }
          if (fieldDijit.onChange) {
            this.connect(fieldDijit, "onChange", lang.hitch(this, "onFieldChange", fieldDijit.name));
          }
          nodes.push(fieldDijit);
          deferred.resolve({
            nodes: nodes,
            fieldDijit: fieldDijit,
            type: type
          });
        }
        return deferred.promise;
      },
      displayWebMapErrors: function (list) {
        if (list) {
          domConstruct.empty(list);
        }
        if (utils && utils.conditionErrors && utils.conditionErrors.length && utils.conditionErrors.length > 0) {
          utils.conditionErrors.forEach(function (errorText) {
            domConstruct.create("li", {
              innerHTML: "<span class='esri-icon-error'></span><span class='error-text'>" + errorText + "</span>"
            }, list);
          });
        }


      },
      _updateEditorText: function () {
        var fieldDijit = this,
          editSpan = dom.byId("span_" + fieldDijit.id);
        domClass.toggle(dom.byId(fieldDijit.id), "hide");
        domClass.toggle(editSpan, "hide");

        if (fieldDijit.value && fieldDijit.value !== "undefined" && fieldDijit.value !== "" && fieldDijit.value !== "isTrusted") {
          editSpan.innerHTML = fieldDijit.value;
        } else if (fieldDijit.tooltip && fieldDijit.tooltip !== "" && fieldDijit.tooltip != "undefined" && fieldDijit.value !== "isTrusted") {
          editSpan.innerHTML = fieldDijit.tooltip;
        }
      },
      _createToolTip: function (field, widget) {
        if (field.tooltip && field.tooltip.length) {
          this.tooltips.push(new Tooltip({
            connectId: [widget.id],
            label: field.tooltip
          }));
        }
      },
      _updateProxyGrid: function (widget) {
        if (widget.proxies && widget.proxies && widget.proxies.length === 0) {
          query("#proxyContainer").style("display", "none");
          query(".esriAppProxySettings").style("display", "none");
        } else {
          query("#proxyContainer").style("display", "block");
          query(".esriAppProxySettings").style("display", "block");
          if (widget && widget._grid) {
            widget._grid.resize();
          }
        }
      },
      _updateSelectedItemDescription: function (type) {
        var details = null;
        if (this.item.multipleItems) {
          details = this.item.multipleItems;
        } else if (this.item.info) {
          details = [this.item.info];
        }
        var detailsType = (details && details.length && details.length > 0 && details[0].type) || null;
        if (detailsType) {
          if (detailsType === "Web Map") {
            detailsType = "webmap";
          } else if (detailsType === "Web Scene") {
            detailsType = "webscene";
          } else {
            detailsType = "group";
          }
        } else if (type === "group") {
          detailsType = "group";
        }
        if (detailsType === type) {
          this._addItemDetails(details, type);
        }

      },
      _addToken: function (portalUrl) {
        // Does url already have token? If so return
        if (portalUrl && portalUrl.indexOf("token") === -1) {
          if (this.portal && this.portal.user && this.portal.user.credential) {
            var token = this.portal.user.credential.token;
            if (token) {
              portalUrl += "?token=" + token;
            }
          }
        }
        return portalUrl;
      },
      _createProxyWidget: function (field) {

        arcgisUtils.arcgisUrl = this.portal.portalUrl + "content/items" || document.location.protocol + "//www.arcgis.com/sharing/rest/content/items";

        var proxyWebmaps = [];
        if (this.values) {
          if (this.values.webmap) {
            if (lang.isArray(this.values.webmap)) {
              array.forEach(this.values.webmap, lang.hitch(this, function (map) {
                proxyWebmaps.push(map);
              }));
            } else {
              proxyWebmaps.push(this.values.webmap);
            }
          }
          if (this.values.webscene) {
            if (lang.isArray(this.values.webscene)) {
              array.forEach(this.values.webscene, lang.hitch(this, function (scene) {
                proxyWebmaps.push(scene);
              }));
            } else {
              proxyWebmaps.push(this.values.webscene);
            }
          }
        }
        var appProxy = new AppProxySettings({
          proxyManagerOptions: {
            appid: this.params.appId
          },
          webmaps: proxyWebmaps
        }, domConstruct.create("div", {
          id: "appProxyWidget"
        }));

        appProxy.on("load", lang.hitch(this, function () {

          var helperServices = this.helperServices;
          var serviceProxies = appProxy.proxies;

          // Check to see if the proxy exists on the app. 
          // Add services proxies used by the app (Route, Traffic etc);
          if (field.serviceProxies) {
            array.forEach(field.serviceProxies, function (service, index) {

              if (helperServices[service.name]) {
                var foundService = helperServices[service.name];

                if (foundService.url.indexOf(".arcgis.com") !== -1) {
                  // Do we already have a proxied version of this url?
                  var found = array.some(serviceProxies, function (p) {
                    if (p.sourceUrl === foundService.url) {
                      return true;
                    } else {
                      return false;
                    }
                  });
                  if (!found) {
                    // only add esri premium content to list
                    serviceProxies.push({
                      id: "serviceProxy" + index,
                      proxied: false,
                      type: "service",
                      sourceUrl: foundService.url,
                      title: service.title
                    });
                  }
                }
              }
            });
          }

          appProxy.set("proxies", serviceProxies);
        }));

        domClass.add(appProxy.domNode, "esriAppProxySettings");

        appProxy.startup();
        appProxy.on("update-proxy", lang.hitch(this, function () {
          this.onFieldChange("appProxies", "update");
        }));
        appProxy.on("create-proxy", lang.hitch(this, function () {
          this.onFieldChange("appProxies", "update");
        }));
        appProxy.on("delete-proxy", lang.hitch(this, function () {
          this.onFieldChange("appProxies", "update");
        }));
        appProxy.watch("webmaps", lang.hitch(this, function () {
          this._updateProxyGrid(appProxy);
        }));
        appProxy.watch("proxies", lang.hitch(this, function () {
          this._updateProxyGrid(appProxy);
        }));

        return appProxy;

      },
      _buildItemDetails: function (type, field) {
        // Create a container to hold the item details.

        var itemContainer = domConstruct.create("div", {
          id: "itemContainer_" + type
        });

        var details = null;
        if (this.item && this.item.multipleItems) {
          details = this.item.multipleItems;
        } else if (this.item && this.item.info) {
          details = [this.item.info];
        }


        var detailsType = (details && details.length && details.length > 0 && details[0].type) || null;
        if (detailsType) {
          if (detailsType === "Web Map") {
            detailsType = "webmap";
          } else if (detailsType === "Web Scene") {
            detailsType = "webscene";
          } else {
            detailsType = "group";
          }
        }

        if (detailsType === type) {
          this._addItemDetails(details, type, itemContainer);
        } else {
          // get details for type? 
          const v = this.values[type];
          if (v) {
            this._getItem(v, type).then(lang.hitch(this, function (item) {
              if (item && item.type === type) {

                this._addItemDetails([item.info], type, itemContainer);
              }

            }));
          }
        }
        return itemContainer;
      },
      _addItemDetails: function (details, type, containerNode) {

        // Add a thumbnail and desc for each item
        var container = containerNode || dom.byId("itemContainer_" + type);
        if (container) {
          domConstruct.empty(container);
        }
        // Build Portal url
        var portalRoot = this.portal.portalUrl || document.location.protocol + "//www.arcgis.com/sharing/rest/";
        // Add a class to make thumbnails smaller if we have more than one
        if (details && details.length && details.length > 1) {
          domClass.add(container, "small");
        } else {
          domClass.remove(container, "small");
        }

        array.forEach(details, lang.hitch(this, function (item) {
          var portalUrl;
          if (type !== "group" && item && item.id && item.thumbnail) {
            portalUrl = portalRoot + "content/items/" + item.id + "/info/" + item.thumbnail;
          } else if (type === "group") {
            if (item && item.thumbnailUrl) {
              portalUrl = item.thumbnailUrl || "";
            }
          }
          portalUrl = this._addToken(portalUrl);

          var title = "<h3>" + item.title + "</h3>";

          var detail = esriLang.substitute({
            thumbnailSrc: portalUrl || "js/esri/dijit/img/default.png",
            itemText: title
          }, detailTemplate);
          domConstruct.place(detail, container, "last");

        }));
        var errorList = domConstruct.create("ul", {
          className: "error-list",
          id: "errorList"
        });
        this.displayWebMapErrors(errorList);
        domConstruct.place(errorList, container, "last");
      },
      _buildBasemapDialog: function (field, titleNodeId) {

        var browseItems = new BrowseItems({
          portalUrl: this.portal.portalUrl || document.location.protocol + "//www.arcgis.com",
          sort: "title",
          "plugin": "configure/dijit/PlugInGroup",
          plugInParams: {
            portal: this.portal,
            user: this.portal.user || null
          },
          queryType: "group",
          style: "width:860px;height:auto;clear:both;",
          selectionMode: "single",
          showInfoPanel: false
        });

        browseItems.startup();
        var widget = domConstruct.create("button", {
          className: "calcite btn blue browse-dialog",
          name: "basemapGroup",
          innerHTML: field.label
        });
        var dialog = new Dialog({
          "title": field.label,
          "content": browseItems.domNode
        }, domConstruct.create("div"));

        dialog.startup();
        // If there is a my content filter activate it the
        // first time we show the dialog
        on.once(browseItems, "grid-ready", function () {
          var content = dom.byId("content");
          if (content) {
            content.click();
          }
        });
        on(widget, "click", lang.hitch(this, function () {
          dialog.show();
        }));

        domClass.add(dialog.cancelButton.domNode, "cancel calcite");
        domClass.add(dialog.okButton.domNode, "ok calcite blue");
        on(dialog, "execute", lang.hitch(this, function () { // Ok button pressed
          var keys = Object.keys(browseItems._grid.selection);
          if (keys && keys.length && keys.length > 0) {
            this.onFieldChange(field.fieldName, keys[0]);
            this._getItem(keys[0], "basemapgroup").then(function (item) {
              dom.byId(titleNodeId).innerHTML = item.title;
            });
          }
        }));

        return widget;
      },
      _buildIdDialog: function (type, field) {
        var label,
          plugInType,
          selectionType = "single",
          selectedItems = null;
        // Multiple selection is allowed (used by compare templates to select more than one web map)
        if (field.hasOwnProperty("selection") && field.selection === "multiple") {
          selectionType = "toggle";
        }
        // Select any saved web maps or web scenes
        if (type === "webmap" && this.values.webmap) {
          // any saved webmaps 
          var multipleItems = this.values.webmap;
          var preselectItems = [];
          if (multipleItems && lang.isArray(multipleItems)) {
            array.forEach(multipleItems, function (w) {
              preselectItems.push(w);
            });
          }
          selectedItems = preselectItems;
        } else if (type === "webscene" && this.values.webscene) {
          var multipleItems = this.values.webscene;
          var preselectItems = [];
          if (multipleItems && lang.isArray(multipleItems)) {
            array.forEach(multipleItems, function (w) {
              preselectItems.push(w);
            });
          }
          selectedItems = preselectItems;
        } else {
          selectedItems = [];
        }


        if (type === "webmap") {
          plugInType = "configure/dijit/PlugInWebMap";
          label = (selectionType === "toggle") ? this.i18n.mapdlg.map_multiple_title : this.i18n.mapdlg.map_title;
        } else if (type === "group") {
          plugInType = "configure/dijit/PlugInGroup";
          label = (selectionType === "toggle") ? this.i18n.mapdlg.group_multiple_title : this.i18n.mapdlg.group_title;
        } else if (type === "webscene") {
          plugInType = "configure/dijit/PlugInWebScene";
          label = (selectionType === "toggle") ? this.i18n.mapdlg.scene_multiple_title : this.i18n.mapdlg.scene_title;
        }

        var browseItems = new BrowseItems({
          portalUrl: this.portal.portalUrl || document.location.protocol + "//www.arcgis.com",
          sort: "title",
          "plugin": plugInType,
          plugInParams: {
            portal: this.portal,
            user: this.portal.user || null
          },
          id: "browse_" + type,
          queryType: (type === "group" ? "group" : "items"),
          style: "width:860px;height:auto;clear:both;",
          selectionMode: selectionType,
          showInfoPanel: (selectionType === "toggle") ? false : true
        });

        if (selectionType === "toggle") {
          browseItems.on("grid-ready", lang.hitch(this, function () {
            var grid = browseItems._grid;
            if (field && field.hasOwnProperty("limit")) {
              // Add a message to the browse dialogs
              query(".messageRight").forEach(lang.hitch(this, function (node) {
                domClass.remove(node, "hide");
                node.innerHTML = esriLang.substitute({
                  count: field.limit,
                  type: (type === "webmap") ? "maps" : "scenes"
                }, this.i18n.mapdlg.max_selection);
              }));
              grid.allowSelect = function (e) {
                var canSelect = true;
                var index = -1;
                if (selectedItems && selectedItems.length && selectedItems.length > 0) {
                  index = selectedItems.indexOf(e.id);
                }
                if (index !== -1) {
                  canSelect = true;
                } else {
                  if (selectedItems && selectedItems.length && selectedItems.length >= Number(field.limit)) {
                    canSelect = false;
                  }
                }
                return canSelect;
              };
            }
            on.once(dialog, "show", function () { // Select any saved items
              array.forEach(selectedItems, function (item) {
                var row = grid.row(item);
                grid.select(row);
              });
            });
            grid.on("dgrid-select, dgrid-deselect", function (e) {
              var row = null,
                eventType = e.type;
              if (e.rows && e.rows.length && e.rows.length > 0) {
                row = e.rows[0];
              }
              if (row && row.id) {
                var index = -1;
                if (selectedItems && selectedItems.length && selectedItems.length > 0) {
                  index = selectedItems.indexOf(row.id);
                }
                if (eventType === "dgrid-select") { // Add to selection
                  if (index === -1) {
                    selectedItems.push(row.id);
                  }
                } else if (eventType === "dgrid-deselect") { // Remove
                  if (index !== -1) {
                    selectedItems.splice(index, 1);
                  }
                }
              }
            });
          }));
        }
        browseItems.startup();
        var widget = domConstruct.create("button", {
          className: "calcite btn blue browse-dialog",
          name: type,
          id: "button_" + type,
          innerHTML: label
        });
        var dialog = new Dialog({
          "title": label,
          "id": "dialog_" + type,
          "content": browseItems.domNode
        }, domConstruct.create("div"));

        dialog.startup();
        // If there is a my content filter activate it the
        // first time we show the dialog
        on.once(browseItems, "grid-ready", function () {
          var content = dom.byId("content");
          if (content) {
            content.click();
          }
        });
        // Show the dialog if nothing is selected
        var selectedItem = null;
        if (type === "webmap") {
          selectedItem = this.values.webmap;
        } else if (type === "webscene") {
          selectedItem = this.values.webscene;
        } else if (type === "group") {
          selectedItem = this.values.group;
        }
        if (selectedItem === undefined || selectedItem === null || selectedItem === []) {
          dialog.show();
        }
        on(widget, "click", lang.hitch(this, function () {
          dialog.show();
        }));

        // If multiple select ok and cancel otherwise delete ok
        domClass.add(dialog.cancelButton.domNode, "cancel calcite");
        domClass.add(dialog.okButton.domNode, "ok calcite blue");
        if (selectionType !== "toggle") {
          domClass.add(dialog.okButton.domNode, "hide");
        }
        on(dialog, "execute", lang.hitch(this, function () { // Ok button pressed
          if (lang.isArray(selectedItems)) {
            if (selectedItems.length === 0) {
              this.values[type] = [];
              this.item = {
                info: null,
                title: null,
                type: null,
                multipleItems: null
              }
            }
          }
          this.onItemSelected({
            id: selectedItems,
            type: type
          });
        }));
        topic.subscribe("/esri/browseitems/close", lang.hitch(this, function (msg, item) {
          if (type === msg && item.id) {
            var params = {
              id: item.id,
              type: type
            };
            this.onItemSelected(params);
          }
          dom.byId("close-panel").click();
          dialog.hide();

        }));
        return widget;
      },
      _updateSmartField: function (field) {
        //The web map has changed so lets update the list of layers that are displayed.
        var layerSelectorNodes = query("." + field.fieldName + "_layers");
        if (layerSelectorNodes && layerSelectorNodes.length && layerSelectorNodes.length > 0) {
          this._updateLayerOptions(layerSelectorNodes[0], field);
          var layerName = layerSelectorNodes[0].id.value || "";
          var field_widget = query("." + field.fieldName + "_fields");
          array.forEach(field_widget, lang.hitch(this, function (w) {
            this._updateFieldOptions(w, w.name, layerName);
          }));
        }
      },
      _updateTree: function (field) {
        //Update the tree to show the new fields when the web map is modified.
        //Destroy and recreate the tree
        var tree = registry.byId(field.fieldName);
        var label = dom.byId("multilayerandfieldselector_" + field.fieldName);

        if (tree) {
          if (label) {
            tree.store = null;
            tree.destroyRecursive();
            this._createMultiLayerField(field).then(function (treenode) {
              if (treenode && treenode.domNode) {
                domConstruct.place(treenode.domNode, label, "after");
              }
            });
          }
        } else {
          this._createMultiLayerField(field).then(function (treenode) {
            if (treenode && treenode.domNode) {
              domConstruct.place(treenode.domNode, label, "after");
            }
          });
        }
      },
      _createMultiLayerField: function (field) {
        var deferred = new Deferred();
        //Build a tree view of the specified layer (and optionally field) types.
        var supportedLayers = this._filterLayers(field);
        var message = dom.byId("err-message" + field.fieldName);
        if (supportedLayers && supportedLayers.length === 0) {
          if (!message) {
            message = domConstruct.create("p", {
              id: "err-message" + field.fieldName,
              name: field.fieldName
            });
          }
          message.innerHTML = "No layers available. Check your web map for valid layers.";
          deferred.resolve(message);

        } else {
          //Remove the no layer message if it exists
          if (message) {
            message.innerHTML = "";
          }
          var supportedFieldTypes = null;
          var geometryTypes = null;
          if (field.fieldOptions && field.fieldOptions && field.fieldOptions.supportedTypes) {
            supportedFieldTypes = field.fieldOptions.supportedTypes;
          }
          if (field.layerOptions && field.layerOptions.hasOwnProperty("geometryTypes")) {
            geometryTypes = field.layerOptions.geometryTypes;
          }

          var tree = new Tree(this.map, supportedLayers, field.fieldName);
          //domClass.add(tree, "smartField");
          tree.validFieldTypes = supportedFieldTypes;
          tree.geometryTypes = geometryTypes;

          connect.connect(tree, "_itemClicked", lang.hitch(this, function (val) {
            var promises = [];
            if (tree && tree.store) {
              tree.store.fetch({
                onItem: lang.hitch(this, function (item) {
                  promises.push(tree._exportTree(item));
                })
              });
            }
            var selected = [];
            all(promises).then(lang.hitch(this, function (results) {
              for (var i = 0; i < results.length; i++) {
                var val = results[i];
                if (lang.isArray(val)) {
                  array.forEach(val, lang.hitch(this, function (v) {
                    selected.push(v);
                  }));
                }
              }
              this.onFieldChange(field.fieldName, dojoJson.toJson(selected));
            }));
          }));
          tree.startup().then(lang.hitch(this, function (node) {
            //update tree config
            var selectedValues = this.values[field.fieldName];
            if (selectedValues && selectedValues.fields && selectedValues.fields.length === 0) {
              selectedValues = null;
            }
            if (selectedValues) {
              tree._updateTree(dojoJson.fromJson(selectedValues));
            }
            connect.connect(node, "onLoad", function () {
              //collapse the multi layer selector if nothing is selected.
              node.collapseAll();
            });
            deferred.resolve(node);
          }), function (error) {
            deferred.resolve(null);
          });
        }
        return deferred.promise;
      },
      _createLayerField: function (field) {
        //Display a list of operational layers in the webmap
        //If 0 or 1 layers are in the map display a disabled text box. If one layer is in the map
        //display the layer in the text box and write it out to the app values.
        //If more than one layer is in the app dispaly a dropdown list of layers.
        //Build a content pane that contains the layer list and optional field list.
        var cp,
          widgets = [],
          params = {},
          supportedLayers = this._filterLayers(field);
        cp = new ContentPane({
          content: "",
          name: field.fieldName,
          className: "panel smartField"
        });
        params = lang.mixin(params, field);
        params.maxHeight = this.defaultMaxSelectHeight;

        // Search for selected option using the values
        var selectedOption = -1;
        params.options = [];
        params.options.push({
          "label": this.i18n.layerAndFields.layer, //"Select layer...",
          "value": ""
        });
        array.map(supportedLayers, lang.hitch(this, function (layer) {
          //Question: layer.id is sometimes undefined so we check for title too.
          params.options.push({
            "label": layer.name || layer.id,
            //use the id if layer name isn't available
            "value": layer.id //|| layer.name
          });
        }));

        //Is there a layer stored in the app values. If there is make sure the layer is
        //in the app
        var some = false;
        if (this.values[field.fieldName] && this.values[field.fieldName].id) {
          var appVal = this.values[field.fieldName].id;
          if (appVal) {
            array.some(params.options, lang.hitch(this, function (option, idx) {
              if (option.value === appVal) {
                some = true;
                selectedOption = idx;
              }
            }));
          }
        }
        var layerId;
        if (supportedLayers && supportedLayers.length > 0) {
          layerId = params.options[(some ? selectedOption : 0)].value;
        }
        //select the first layer or the layer id that matches the info in /data
        params.options[(some ? selectedOption : 0)].selected = true;
        // Here we set the layer id to the first layer in the map if nothing is selected.
        //If there aren't any layers write out an empty string for the layer  name
        this.configurationValues[field.fieldName] = { //write out value
          id: layerId,
          fields: []
        };
        if (supportedLayers && supportedLayers.length < 1) {
          //Disable the widget if there aren't any layers
          params.style = "color:#ccc";
          params.disabled = true;
        }

        var select = new Select(params);
        domClass.add(select.domNode, field.fieldName + "_layers");

        connect.connect(select, "onChange", lang.hitch(this, function (value) {
          var newValue = {};
          if (typeof value === "string") {
            //layer id and empty field array if one isn't specified. ???
            newValue.id = value;
            if (!newValue.fields) {
              newValue.fields = [];
            }
            //Layer field changed. Update field list for the layer
            //also pass in widget.name which is same as the fieldName
            var ms_widget = query("." + select.fieldName + "_fields");
            array.forEach(ms_widget, lang.hitch(this, function (ms) {
              this._updateFieldOptions(ms, ms.name, value);
            }));
          }
          //call onchange with the new value and the name of the parent widget. The
          //name of the parent widget (content pane) will be the field name
          this.onFieldChange(select.fieldName, newValue);
        }));

        widgets.push(select.domNode);
        //add the field widget. If no fields then just hide.
        if (field.fields !== null && field.fields !== undefined) {
          array.forEach(field.fields, lang.hitch(this, function (category_field) {
            //default to true
            var multiple = true,
              layerid = null,
              fieldWidget = null;

            var layerAndFieldsWidgetId = field.fieldName;
            if (category_field.hasOwnProperty("multipleSelection")) {
              multiple = category_field.multipleSelection;
            }
            //Check the config file to see if there are values for the widget stored.
            if (supportedLayers && supportedLayers.length > 0) {
              layerid = this.configurationValues[layerAndFieldsWidgetId].id;
            }
            fieldWidget = this._buildFieldDropdown(layerid, layerAndFieldsWidgetId, category_field.fieldName, multiple);
            if (fieldWidget !== null) {
              //add a label if one has been specified
              if (category_field.hasOwnProperty("label")) {
                widgets.push(domConstruct.create("label", {
                  "for": fieldWidget.id,
                  "innerHTML": category_field.label
                }, null));
              }
              widgets.push(fieldWidget);
            }
          }));
        }
        //add the widget(s) to the content pane
        cp.set("content", widgets);
        return cp.domNode;
      },
      _createOptionsField: function (field) {
        var params = {
          maxHeight: this.defaultMaxSelectHeight,
          name: field.fieldName
        };
        params = lang.mixin(params, field);
        // Search for selected option using the values
        var selectedOption = -1;
        var some = array.some(params.options, lang.hitch(this, function (option, idx) {
          selectedOption = idx;
          return (option.value === this.values[field.fieldName]) ? idx : false;
        }));
        params.options[(some ? selectedOption : 0)].selected = true;
        return new Select(params);
      },
      _createStringField: function (field) {
        var stringWidget = null;
        var params = {
          regExp: ".*",
          constraints: {},
          trim: true,
          intermediateChanges: true,
          name: field.fieldName,
          value: this.values[field.fieldName] || ""
        };
        params = lang.mixin(params, field);
        if (field.stringFieldOption && field.stringFieldOption === FormBuilder.STRING_FIELD_OPTION_TEXTAREA) {
          params["class"] += " esriFormBuilderTextAreaField";
          params.rows = field.rows || this.defaultTextAreaSize;
          params.columns = field.columns || this.defaultTextAreaSize;
          stringWidget = new SimpleTextarea(params);
        } else if (field.stringFieldOption && field.stringFieldOption === FormBuilder.STRING_FIELD_OPTION_RICHTEXT) {
          params["class"] += " esriFormBuilderRichTextField";
          params.plugins = [
            "bold", "italic", "underline", "foreColor", "hiliteColor", "|", "justifyLeft", "justifyCenter", "justifyRight",
            "justifyFull", "|", "insertOrderedList", "insertUnorderedList", "indent", "outdent", "|", "createLink", "unlink",
            "insertImage", "removeFormat", "|", "undo", "redo", "|", "viewsource",
            {
              name: "dijit._editor.plugins.FontChoice",
              command: "fontSize",
              "class": "dijitFontSizeWrap",
              custom: ["2", "3", "4", "5", "6"]
            }
          ];
          params.style = "font-family: 'Avenir LT W01 35 Light', 'Avenir Next', 'Avenir', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;font-size: 15px;";
          stringWidget = new Editor(params);
        } else {
          stringWidget = new ValidationTextBox(params);
        }
        stringWidget.startup();
        return stringWidget;
      },

      _createBooleanField: function (field) {
        var addToForm = true;
        if (field && field.condition) {
          addToForm = utils.evalBooleanCondition(field.condition);
        }
        var checkContainer = domConstruct.create("div");
        var params = lang.mixin({
          value: true,
          name: field.fieldName
        }, field);
        params.checked = esriLang.isDefined(this.values[field.fieldName]) ? this.values[field.fieldName] : true;
        var checkbox = new CheckBox(params);
        domClass.add(checkbox.domNode, field.fieldName);
        if (checkbox.onChange) {
          this.connect(checkbox, "onChange", lang.hitch(this, "onFieldChange", checkbox.name));
        }
        checkContainer.appendChild(checkbox.domNode);
        if (field.label) {
          var label = this._createLabel(field, checkbox.id);
          domClass.add(label, field.fieldName);
          checkContainer.appendChild(label);
        }
        if (!addToForm) {
          domClass.add(checkbox.domNode, ["hide-condition"]);
          if (label) {
            domClass.add(label, ["hide-condition"]);
          }
        }
        return checkContainer;
      },
      _createConditionalField: function (field) {
        var deferred = new Deferred();
        var params = lang.mixin({
          value: true,
          name: field.fieldName
        }, field);
        var widgets = [];

        var cp = new ContentPane({
          content: "",
          name: field.fieldName,
          className: "panel conditional"
        });
        params.checked = esriLang.isDefined(this.values[field.fieldName]) ? this.values[field.fieldName] : true;
        var check = new CheckBox(params);
        if (params.checked && params.condition === false) {
          domClass.add(cp.domNode, "add-shading");
        }
        connect.connect(check, "onChange", lang.hitch(this, function (value) {
          var hide = this._updateConditionalContent(field, value);
          if (hide) {
            domClass.remove(cp.domNode, "add-shading");
          } else {
            domClass.add(cp.domNode, "add-shading");
          }
          this.onFieldChange(field.fieldName, value);
        }));
        // Create label
        widgets.push(check.domNode);
        widgets.push(this._createLabel(field, check.id));
        widgets.push(domConstruct.create("br"));
        var promises = [];

        field.items.forEach(lang.hitch(this, function (item) {
          promises.push(this._createField(item).then(lang.hitch(this, function (results) {
            return results;
          })));
        }));
        all(promises).then(lang.hitch(this, function (response) {

          response.forEach(lang.hitch(this, function (w, i) {
            if (w.nodes) {
              var isChecked = esriLang.isDefined(this.values[field.fieldName]) ? this.values[field.fieldName] : true;
              w.nodes.forEach(lang.hitch(this, function (node) {
                node = node.domNode || node;
                widgets.push(node);
                if (domClass.contains(node, "esriCheckBoxLabel")) {
                  var brnode = domConstruct.create("br", {
                    className: "conditional  conditional-inset conditional-" + field.fieldName
                  });
                  if (isChecked === field.condition) {
                    domClass.add(brnode, "conditional-hide");
                  }
                  widgets.push(brnode);
                }
                domClass.add(node, ["conditional", "conditional-inset", "conditional-" + field.fieldName]);
                if (isChecked === field.condition) {
                  domClass.add(node, "conditional-hide");
                }
              }));
            }
          }));

          cp.set("content", widgets);

          deferred.resolve(cp.domNode);
        }), function (e) {
          deferred.resolve();
        });
        return deferred.promise;
      },
      _createLabel: function (field, id) {
        var labelType = (field.type === "layerandfieldselector") ? "p" : "label";
        var type = (field.type && field.type.toLowerCase()) || "string";
        var labelText = field.label || "";
        var label = domConstruct.create(labelType, {
          "innerHTML": labelText + "&#8206;",
          "id": type + "_" + field.fieldName,
          "class": type
        }, null);
        if (field.type === "boolean" || field.type === "conditional") {
          domClass.add(label, "esriCheckBoxLabel");
        }
        if (id) {
          domAttr.set(label, "for", id);
        }
        return label;
      },
      _updateConditionalContent: function (field, value) {
        var hide = false;
        if (value === field.condition) {
          // if checkbox equals condition hide content
          query(".conditional-" + field.fieldName).forEach(function (node) {
            domClass.add(node, "conditional-hide");
            hide = true;
          });
        } else {
          query(".conditional-" + field.fieldName).forEach(lang.hitch(this, function (node) {
            domClass.remove(node, "conditional-hide");
            hide = false;
          }));
        }
        return hide;
      },
      _createSearchConfig: function (field) {
        // The various sources don't enforce a unique name/url and we don't have an id stored
        // with the helper services and the id stored with configured web map searches is the
        // so in the widget we will only add a source with the same name and url one time.
        // We'll start with values from the app then add helper services, web map items and finally
        // feature layers in the map.
        // Get any configured sources from the app
        var appValues = this.values[field.fieldName];
        var searchAll = false,
          activeSourceIndex = null;
        if (appValues && appValues.hasOwnProperty("enableSearchingAll")) {
          searchAll = appValues.enableSearchingAll;
        }
        if (appValues && appValues.hasOwnProperty("activeSourceIndex")) {
          activeSourceIndex = appValues.activeSourceIndex;
        }
        var searchConfig = {
          sources: [],
          activeSourceIndex: activeSourceIndex,
          enableSearchingAll: searchAll
        };
        if (appValues) {
          var savedSources = [];
          array.forEach(appValues.sources, lang.hitch(this, function (s) {

            if (s.hasOwnProperty("locator")) {
              s.locator = new Locator(s.url);
            }
            savedSources.push(s);
          }));
          appValues.sources = savedSources;
          lang.mixin(searchConfig, appValues);
        }
        searchConfig.sources = this._updateSources(searchConfig.sources, appValues);
        var searchConfigWidget = new SearchConfig({
          name: field.fieldName,
          map: this.map || null,
          config: searchConfig
        }, domConstruct.create("div", {
          id: field.fieldName + "_search"
        }));
        searchConfigWidget.startup();
        searchConfigWidget.watch("config", lang.hitch(this, function (name, oldValue, value) {
          var searchAll = false;
          if (value.hasOwnProperty("enableSearchingAll")) {
            searchAll = value.enableSearchingAll;
          }
          var updatedSources = {
            sources: [],
            activeSourceIndex: value.activeSourceIndex,
            enableSearchingAll: searchAll
          };
          array.forEach(value.sources, lang.hitch(this, function (v, index) {
            if (v.enable) {
              var updateSource = lang.mixin({}, v);
              if (updateSource.hasOwnProperty("locator")) {
                updateSource.locator = new Locator(updateSource.url);
              }
              if (updateSource.hasOwnProperty("featureLayer")) {
                delete updateSource.featureLayer;
              }
              updatedSources.sources.push(updateSource);
            }
          }));
          this.onFieldChange(searchConfigWidget.name, updatedSources);
        }));
        return searchConfigWidget;
      },
      _updateSources: function (searchSources, appValues) {

        // Add sources from org, app and map
        var searchConfigSources = [];
        searchSources.forEach(function (source) {
          if (source && source.hasOwnProperty("placefinding") && source.placefinding === true) {
            // placefinding true add to sources 
            searchConfigSources.push(source);
          } else if (source.name && source.name === "Esri World Geocoder") {
            searchConfigSources.push(source);
          } else {
            searchConfigSources.push(source);
          }
        });
        // Helper Services from org
        if (this.portal && this.portal.helperServices && this.portal.helperServices.geocode) {
          array.forEach(this.portal.helperServices.geocode, lang.hitch(this, function (geocode) {

            if (geocode && geocode.url) {
              if (!this._sourceExists(searchConfigSources, geocode)) {
                var locatorSource = {
                  locator: new Locator(geocode.url)
                };
                lang.mixin(locatorSource, geocode);

                // Config requires enableSuggestions not suggest so update
                // then delete suggest property
                if (locatorSource.hasOwnProperty("suggest")) {
                  locatorSource.enableSuggestions = locatorSource.suggest;
                  delete locatorSource.suggest;
                }
                if (locatorSource.url.indexOf(".arcgis.com/arcgis/rest/services/World/GeocodeServer") > -1) {
                  locatorSource.singleLineFieldName = "SingleLine";
                  locatorSource.name = locatorSource.name || this.i18n.searchConfig.worldLocator;
                }

                if (!locatorSource.hasOwnProperty("enable") && !appValues) {
                  locatorSource.enable = true;
                }
                // Check placefinding and don't add if exists and false. 
                if (locatorSource && locatorSource.hasOwnProperty("placefinding") && locatorSource.placefinding === true) {
                  // placefinding true add to sources 
                  searchConfigSources.push(locatorSource);
                } else if (locatorSource.name && locatorSource.name === "Esri World Geocoder") {
                  searchConfigSources.push(locatorSource);
                }
              }
            }
          }));
        }
        // Add a source for any locators configured on the web map item
        // These are configured via the web map item details page in ArcGIS Online

        if (this.item && this.item.info && this.item.info.applicationProperties && this.item.info.applicationProperties.viewing && this.item.info.applicationProperties.viewing.search) {
          var searchOptions = this.item.info.applicationProperties.viewing.search;
          array.forEach(searchOptions.layers, lang.hitch(this, function (searchLayer) {
            var operationalLayers = this.item.info.operationalLayers,
              layer = null;
            array.some(operationalLayers, function (opLayer) {
              if (opLayer.id === searchLayer.id) {
                layer = opLayer;
                return true;
              }
            });
            if (layer && layer.hasOwnProperty("url")) {

              var source = {},
                url = layer.url,
                name = layer.title || layer.name;

              if (!this._sourceExists(searchConfigSources, layer)) {
                // doesn't exist so add it
                if (esriLang.isDefined(searchLayer.subLayer)) {
                  url = url + "/" + searchLayer.subLayer;
                  array.some(layer.layerObject.layerInfos, function (info) {
                    if (info.id === searchLayer.subLayer) {
                      name += " - " + layer.layerObject.layerInfos[searchLayer.subLayer].name;
                      return true;
                    }
                  });
                }
                source.enable = searchOptions.enabled || false;
                source.featureLayer = new FeatureLayer(url);
                source.flayerId = layer.id;
                source.layerId = layer.id;
                source.name = name;
                source.url = url;
                source.exactMatch = searchLayer.field.exactMatch;
                source.searchFields = [searchLayer.field.name];
                source.displayField = searchLayer.field.name;
                source.outFields = ["*"];
                source.placeholder = searchOptions.hintText;
                searchConfigSources.push(source);
              }
            }
          }));
        }
        // Add operational layers (feature layers) from the map as search sources


        if (this.item && this.item.item && this.item.item.operationalLayers) {
          var operationalLayers = this._getWebMapLayers(this.item.item, true);
          array.forEach(operationalLayers, lang.hitch(this, function (layer) {

            var source = {};
            if (!this._sourceExists(searchConfigSources, layer.layer)) {
              if (layer.layer && layer.layer.type && layer.layer.url) {
                if (layer.layer.type === "Feature Layer" || (layer.layer.hasOwnProperty("subLayerIds") && layer.layer.subLayerIds !== null && layer.layer.type !== "Layer")) {
                  // Source doesn't exist so let's add it

                  source = {
                    featureLayer: this._getFeatureLayer(layer.layer),
                    flayerId: layer.layer.id,
                    url: layer.url || layer.layer.url || null,
                    name: layer.layer.name || layer.title
                  };
                  searchConfigSources.push(source);
                }

              }
            }
          }));
        }
        return searchConfigSources;
      },

      _getFeatureLayer: function (s) {
        // Is the layer in the map? If so get it if not create one.
        var flayer = null;
        if (s.hasOwnProperty("flayerId") || s.hasOwnProperty("id")) {
          var id = s.flayerId || s.id;
          flayer = this.map.getLayer(id);
        }
        if (!flayer && s.url) {
          flayer = new FeatureLayer(s.url);
        }
        return flayer;
      },
      _sourceExists: function (searchConfigSources, checkSource) {
        return array.some(searchConfigSources, lang.hitch(this, function (source) {
          var id = null,
            sourceId = null;
          if (checkSource.hasOwnProperty("featureLayer")) {
            id = checkSource.featureLayer.id;
            delete checkSource.featureLayer;
          }
          if (!id) {
            id = checkSource.flayerId || checkSource.id || null;
          }

          if (source.hasOwnProperty("featureLayer")) {
            sourceId = source.featureLayer.id;
            delete source.featureLayer;
          }
          if (!sourceId) {
            sourceId = source.flayerId || source.id;
          }

          var name = checkSource.name || checkSource.title || null;
          var url = checkSource.url || null;
          if (url && source.url) {
            if (source.url === url) {
              return true;
            }
          } else {
            if (sourceId === id && source.name === name) {
              //update the source feature layer
              if (!source.featureLayer) {
                source.featureLayer = this._getFeatureLayer(checkSource);
              }
              return true;
            }
          }
        }));
      },
      _existsInLocatorSources: function (sources, url, name) {
        return array.some(sources, function (source) {
          var sourceUrl = null;
          if (source.locator && source.locator.url) {
            sourceUrl = source.locator.url;
          } else if (source.featureLayer && source.featureLayer.url) {
            sourceUrl = source.featureLayer.url;
          }
          // If we change the locator name we'll have two listed
          // so we store the original name and compare it.
          if (source.name === name && sourceUrl === url) {
            return true;
          }
        });
      },
      _createRadioButtonGroup: function (field) {
        var params = lang.mixin({
          name: field.fieldName
        }, field);

        var form = new ContentPane({
          content: "",
          name: field.fieldName,
          className: "panel"
        });
        var checkedVal = this.values[field.fieldName] || null;
        array.forEach(field.items, lang.hitch(this, function (item) {
          if (checkedVal) {
            if (checkedVal === item.value) {
              item.checked = true;
            } else {
              item.checked = false;
            }
          }

          var button = new RadioButton({
            checked: item.checked || false,
            value: item.value,
            name: field.fieldName
          }, domConstruct.create("input", {}, form.containerNode));
          domConstruct.create("label", {
            "for": button.id,
            "className": "radioLabel",
            "innerHTML": item.label
          }, form.containerNode);

          button.startup();
        }));
        params.value = esriLang.isDefined(this.values[field.fieldName]) ? this.values[field.fieldName] : (field.min || NaN);
        form.startup();
        return form;
      },
      _createNumberField: function (field) {
        var params = lang.mixin({
          name: field.fieldName
        }, field);
        params.value = esriLang.isDefined(this.values[field.fieldName]) ? this.values[field.fieldName] : (field.min || NaN);
        return new NumberTextBox(params);
      },
      _createHeader: function (field) {
        var params = lang.mixin({
          name: field.fieldName || "",
          className: "subcategory"
        }, field);
        params.innerHTML = field.label || "";
        params.innerHTML += "&#8206;";
        return domConstruct.create("h1", params);
      },
      _createParagraph: function (field) {
        var params = lang.mixin({
          name: field.fieldName || ""
        }, field);
        params.innerHTML = field.value || "";
        params.innerHTML += "&#8206;";
        return domConstruct.create("p", params);
      },

      _createFrame: function (field) {
        return "<div style='height:100%;width:100%;' id='appViewFrame'></div>";
      },
      _createColor: function (field) {
        var id = field.fieldName;
        if (field.sharedThemeProperty) {
          id = field.sharedThemeProperty.replace(".", "");
        }
        var params = {
          name: field.fieldName,
          required: true,
          //id: id,
          showTransparencySlider: false,
          showRecentColors: false,
          collapsible: true,
          collapsed: true,
          fieldLabel: field.label || null
        };
        var cp = new ColorPicker(params);

        cp.startup();
        if (this.values[field.fieldName]) {
          cp.set("color", this.values[field.fieldName]);
        }

        cp.on("color-change", lang.hitch(this, function (evt) {
          if (evt && evt.color) {
            this.onFieldChange(cp.name, evt.color.toHex());
          }

        }));

        return cp;
      },
      _buildScaleList: function (type, field) {
        var options = [{
            "label": "Default",
            "value": null
          }, {
            "label": "World",
            "value": "100000000"
          }, {
            "label": "Continent",
            "value": "50000000"
          },
          {
            "label": this.i18n.scale.countriesBig,
            "value": "25000000"
          },
          {
            "label": this.i18n.scale.countriesSmall,
            "value": "12000000"
          },
          {
            "label": this.i18n.scale.states,
            "value": "6000000"
          },
          {
            "label": this.i18n.scale.state,
            "value": "3000000"
          },
          {
            "label": this.i18n.scale.counties,
            "value": "1500000"
          },
          {
            "label": this.i18n.scale.county,
            "value": "750000"
          },
          {
            "label": this.i18n.scale.metro,
            "value": "320000"
          },
          {
            "label": this.i18n.scale.cities,
            "value": "160000"
          },
          {
            "label": this.i18n.scale.city,
            "value": "80000"
          },
          {
            "label": this.i18n.scale.town,
            "value": "40000"
          },
          {
            "label": this.i18n.scale.neighborhood,
            "value": "20000"
          },
          {
            "label": this.i18n.scale.streets,
            "value": "10000"
          },
          {
            "label": this.i18n.scale.street,
            "value": "5000"
          },
          {
            "label": this.i18n.scale.buildings,
            "value": "2500"
          },
          {
            "label": this.i18n.scale.building,
            "value": "1250"
          }
        ];

        var select = new Select({
          options: options,
          name: field.fieldName
        }, domConstruct.create("div"));
        if (this.values[field.fieldName]) {
          select.set("value", this.values[field.fieldName]);
        }
        return select;

      },
      _buildBasemapList: function (type, field) {
        var options = [];
        for (var key in esriBasemaps) {
          if (esriBasemaps.hasOwnProperty(key)) {
            var basemap = esriBasemaps[key];
            options.push({
              label: basemap.title,
              value: key
            });
          }
        }
        var select = new Select({
          options: options,
          name: field.fieldName
        }, domConstruct.create("div"));
        if (this.values[field.fieldName]) {
          select.set("value", this.values[field.fieldName]);
        }
        return select;
      },
      _buildFieldDropdown: function (layerid, widgetid, fieldName, multiple) {
        //Create a dropdown list that displays the fields associated
        //with the selected layer. First create a select list with the fields
        //as options and use that with dojo's multiselect widget to display
        //a list of fields. We want to create a field even if there isn't anything to display.
        var fields = null,
          fieldDropdown = domConstruct.create("select", {}),
          fieldsArray = [],
          selectedOptions = [],
          selectedFields = [];
        if (layerid) {
          fields = this._getFields(this.map.getLayer(layerid), fieldName); //layer.fields;
        } else {
          fields = [];
        }

        //Figure out if there are any values stored for this field in the
        //app configuration. If there are then apply them to the panel.
        if (this.values[widgetid] && this.values[widgetid].fields) {
          var layerFields = this.values[widgetid].fields;

          array.forEach(layerFields, lang.hitch(this, function (f) {
            if (f.id) {
              if (f.id === fieldName) { //fields for the appropriate widget?
                if (f.fields) {
                  selectedFields = f.fields;
                }
              }
            }

          }));
        }
        fieldDropdown.appendChild(
          domConstruct.create("option", {
            "innerHTML": this.i18n.layerAndFields.field, //"Select field...",
            "value": ""
          }));
        array.forEach(fields, lang.hitch(this, function (layerField) {
          var f = domConstruct.create("option", {
            "innerHTML": layerField.alias || layerField.name,
            "value": layerField.name
          });

          array.forEach(selectedFields, lang.hitch(this, function (sel) {
            if (sel === layerField.name) {
              selectedOptions.push(layerField.name);
              fieldsArray.push(layerField);
            }
          }));
          fieldDropdown.appendChild(f);
        }));

        //write out the selected fields to the app
        if (widgetid && fieldName) {
          if (this.configurationValues[widgetid] && this.configurationValues[widgetid].fields) {
            //add to the existing array
            array.forEach(this.configurationValues[widgetid].fields, lang.hitch(this, function (c) {
              if (c.id === fieldName) {
                c.values = fieldsArray;
              } else {
                this.configurationValues[layerid].fields.push({
                  id: fieldName,
                  values: fieldsArray
                });
              }
            }));

          } else {
            this.configurationValues[layerid].fields.push({
              id: fieldName,
              values: fieldsArray
            });
          }
        }

        //When multiple is false a select list is displayed.
        var multiselect = new MultiSelect({
          name: fieldName,
          className: widgetid + "_fields",
          multiple: multiple
        }, fieldDropdown);

        //disable the widget if no fields exist for layer
        if (fields.length < 1) {
          multiselect.set("disabled", true);
        } else {
          multiselect.set("disabled", false);
        }
        //For some reason all the options are set to selected when first displayed. Here we
        //set the selection to the fields specified in the application values. If no fields are
        //specified the selection is cleared.
        multiselect.set("value", selectedOptions);

        if (multiselect.onChange) {
          connect.connect(multiselect, "onChange", lang.hitch(this, function (value) {
            var obj = {},
              newValue = {};
            obj.id = multiselect.name;
            obj.fields = value;
            if (newValue.fields) {
              newValue.fields.push(obj);
            } else {
              newValue.fields = [obj];
            }
            this.onFieldChange(widgetid, newValue);
          }));
        }
        return multiselect.domNode;
      },
      _updateLayerOptions: function (widget, field) {
        //Remove the existing options
        var select = registry.byId(widget.id);
        var options = select.options;

        array.forEach(options, lang.hitch(this, function (option) {
          option.selected = false;
          select.removeOption(option);
        }));
        //add the new options and make none the first option in the array.
        var supportedLayers = this._filterLayers(field);
        select.addOption({
          "label": this.i18n.layerAndFields.layer, // Selecct Layer
          "value": ""
        });
        array.forEach(supportedLayers, lang.hitch(this, function (layer) {
          select.addOption({
            "label": layer.name || layer.id,
            //use the id if layer name isn't available
            "value": layer.id
          });
        }));
        //disable the widget if no layers are available
        if (supportedLayers && supportedLayers.length < 1) {
          this._disableWidget(select, true);
        } else {
          this._disableWidget(select, false);
        }
        select.reset();
      },
      _disableWidget: function (widget, disabled) {
        if (disabled) {
          widget.set("disabled", true);
          domStyle.set(widget.domNode, "color", "#ccc");
        } else {
          widget.set("disabled", false);
          domStyle.set(widget.domNode, "color", "inherit");
        }
      },
      _updateFieldOptions: function (widget, fieldName, layerId) {
        //Remove existing options
        array.forEach(widget.options, lang.hitch(this, function (option) {
          widget.remove(option);
        }));
        //get new options and append them
        var fields = [];
        var layer = this.map.getLayer(layerId);
        if (layer) {
          fields = this._getFields(layer, fieldName);
        }

        widget.add(domConstruct.create("option", {
          "innerHTML": this.i18n.layerAndFields.field, //"Select field...",
          "value": ""
        }));
        array.forEach(fields, lang.hitch(this, function (layerField) {
          widget.add(domConstruct.create("option", {
            "innerHTML": layerField.alias || layerField.name,
            "value": layerField.name
          }));
        }));

        //disable the widget if no fields exist
        var widgetObj = registry.byId(widget.id);
        if (fields.length < 1) {
          widgetObj.set("disabled", true);
        } else {
          widgetObj.set("disabled", false);
        }
      },
      _getFields: function (layer, fieldName) {
        if (layer === undefined) {
          return [];
        }
        var fieldTypes = [],
          fields = [];
        //get supported field types (esriFieldTypeString etc)
        array.forEach(this.categories, lang.hitch(this, function (category) {
          array.forEach(category.fields, lang.hitch(this, function (field) {
            if (field.type === "layerAndFieldSelector") {
              if (field.fields) {
                array.some(field.fields, lang.hitch(this, function (subfield) {

                  if (fieldName === subfield.fieldName && subfield.supportedTypes) {
                    fieldTypes = subfield.supportedTypes;
                    return true;
                  }
                }));
              }
            }
          }));
        }));
        //Sometimes the objectid field is of type integer. Filter this out if the
        //type specified isn't OID.
        var oidField = null;
        if (layer.objectIdField) {
          oidField = layer.objectIdField;
        }
        if (fieldTypes.length > 0) {
          array.forEach(layer.fields, lang.hitch(this, function (field) {
            array.forEach(fieldTypes, function (type) {
              if (type === "esriFieldTypeOID" && field.type === type) {
                fields.push(field);
              } else if (field.type === type && field.name !== oidField) {
                fields.push(field);
              }
            });
          }));
        } else {
          //no field types listed so let's display everything
          if (layer.fields) {
            fields = layer.fields;
          }

        }
        return fields;
      },
      _filterLayers: function (field) {

        var filteredLayers = [];

        var supportedTypes = [],
          geometryTypes = [];
        if (field.layerOptions && field.layerOptions.hasOwnProperty("supportedTypes")) {
          supportedTypes = field.layerOptions.supportedTypes;
        }
        if (field.layerOptions && field.layerOptions.hasOwnProperty("geometryTypes")) {
          geometryTypes = field.layerOptions.geometryTypes;
        }

        //If geometry types is populated we only care about feature layers and feature collections

        if (geometryTypes.length > 0) {
          array.forEach(this.operationalLayers, lang.hitch(this, function (layer) {

            var supportedLayer = this._checkSupportedTypes(supportedTypes, layer);
            if (supportedLayer) {
              if (layer.geometryType) {
                array.forEach(geometryTypes, function (gtype) {
                  if (gtype === layer.geometryType) {

                    filteredLayers.push(layer);
                  }
                });
              } else {
                filteredLayers.push(layer);
              }
            }

          }));
        } else if (supportedTypes.length > 0) {
          //Filter the list to only display supported types
          array.forEach(this.operationalLayers, lang.hitch(this, function (layer) {

            var l = this._checkSupportedTypes(supportedTypes, layer);
            if (l) {
              filteredLayers.push(l);
            }
          }));

        } else {
          //no supported types and no geometry types listed lets just list everything
          filteredLayers = this.operationalLayers;
        }
        //return this.operational Layers;
        return filteredLayers;
      },
      _checkSupportedTypes: function (supportedTypes, layer) {
        var supportedLayer = null;
        supportedTypes.push("TiledLayer");
        array.forEach(supportedTypes, lang.hitch(this, function (stype) {

          switch (stype) {
            case "MapServiceLayer":
              if (layer.declaredClass === "esri.layers.ArcGISDynamicMapServiceLayer") {
                supportedLayer = layer;
              }
              if (layer.type && layer.type === "Layer") { //support flatten
                supportedLayer = layer;
              }
              break;
            case "VectorTiledLayer":
              if (layer.declaredClass === "esri.layers.VectorTileLayer") {
                supportedLayer = layer;
              }
              break;
            case "ImageServiceLayer":
              if (layer.declaredClass === "esri.layers.ArcGISImageServiceLayer") {
                supportedLayer = layer;
              }
              break;
              //updated flayer and fcollection 1/24/2014
            case "FeatureLayer":
              if (layer.type === "Feature Layer" && layer.url !== null) {
                supportedLayer = layer;
              }
              break;
            case "FeatureCollection":
              //this._isMapNotesLayer(layer);
              if (layer.type === "Feature Layer" && !layer.url) {
                supportedLayer = layer;
              }
              break;
            default:

          }
        }));
        return supportedLayer;
      },
      _getWebMapLayers: function (itemData, flatten) {
        var layerInfos = [];
        var layers = itemData.baseMap.baseMapLayers.concat(itemData.operationalLayers);
        array.forEach(layers, lang.hitch(this, function (mapLayer, index) {
          var layerInfo = {};
          if (mapLayer && mapLayer.errors && mapLayer.errors.length && mapLayer.errors.length > 0) {
            console.log("Invalid layer found: " + mapLayer.title);
            return;
          }

          if (mapLayer.featureCollection && mapLayer.type !== "CSV") {
            if (this._isMapNotesLayer(mapLayer.featureCollection)) {
              var l = mapLayer.featureCollection.layer || mapLayer.featureCollection.layers[0];
              //give the layer name the title so it appears correctly in the dropdown. For
              //example we'd rather see Race Locations than Areas.
              l.layerObject.name = mapLayer.title;
              l.layerObject._mapNotes = true;

              layerInfo = {
                "layer": l.layerObject,
                "title": mapLayer.title
              };
              layerInfos.push(layerInfo);

            } else {
              array.forEach(mapLayer.featureCollection.layers, lang.hitch(this, function (fcMapLayer) {
                var title = mapLayer.title;
                if (fcMapLayer.layerObject && fcMapLayer.layerObject.name) {
                  title = fcMapLayer.layerObject.name;
                }
                layerInfo = {
                  "layer": fcMapLayer.layerObject,
                  "title": title
                };
                layerInfos.push(layerInfo);
              }));
            }
          } else if ((mapLayer.baseMapLayer && mapLayer.layerObject) || (!mapLayer.baseMapLayer && mapLayer.layerObject)) {
            if (flatten && mapLayer.layerObject && mapLayer.layerObject.layerInfos) {
              array.forEach(mapLayer.layerObject.layerInfos, lang.hitch(this, function (subLayer) {
                var title = subLayer.name + " | " + mapLayer.title + "";
                subLayer.name = title;
                subLayer.url = mapLayer.layerObject.url + "/" + subLayer.id;
                subLayer.type = "Layer";

                subLayer.id = mapLayer.id + "." + subLayer.id;
                layerInfo = {
                  "layer": subLayer,
                  "title": title
                };
                layerInfos.push(layerInfo);
              }));
            } else {
              if (mapLayer.layerObject && !mapLayer.layerObject.name) {
                mapLayer.layerObject.name = mapLayer.title;
              } else if (mapLayer.layerObject.name && mapLayer.title) {
                mapLayer.layerObject.name = mapLayer.title;
              }
            }
            layerInfo = {
              "layer": mapLayer.layerObject,
              "title": mapLayer.title
            };

            layerInfos.push(layerInfo);
          }
        }));
        return layerInfos;
      },
      _processLayers: function (response) {
        var operationalLayers = [],
          layers = null;
        if (response.itemInfo && response.itemInfo.itemData) {
          layers = this._getWebMapLayers(response.itemInfo.itemData, false);
        }

        if (layers) {
          array.forEach(layers, function (layer) {
            if (layer.layer) {
              operationalLayers.push(layer.layer);
            }
          });
        }
        return operationalLayers;

      },
      _isMapNotesLayer: function (mapLayer) {
        var featColl;
        if (mapLayer.layer) {
          featColl = mapLayer.layer;
        } else {
          featColl = mapLayer.layers[0];
        }
        return this._isMapNotesFeatColl(featColl);
      },
      _isMapNotesFeatColl: function (featureColl) {
        var fieldNames = ",",
          sep = "";
        // just check one layer
        if (featureColl.layerDefinition && featureColl.layerDefinition.fields) {
          array.forEach(featureColl.layerDefinition.fields, lang.hitch(this, function (field) {
            fieldNames += sep + field.name;
            sep = ",";
          }));
        }
        fieldNames = fieldNames.toLowerCase();
        var fieldInfos = this._getFieldInfos();
        for (var i = 0; i < fieldInfos.length; i++) {
          var fieldName = fieldInfos[i].fieldName.toLowerCase();
          if (fieldNames.indexOf("," + fieldName + ",") === -1) {
            fieldInfos = null;
            return false;
          }
        }
        return true;
      },
      _getFieldInfos: function () {
        // Look for fields in a map notes layer
        var fieldInfos = [{
            fieldName: "TITLE"
          },
          {
            fieldName: "DESCRIPTION"
          },
          {
            fieldName: "IMAGE_URL"
          },
          {
            fieldName: "IMAGE_LINK_URL"
          }
        ];
        return fieldInfos;
      },
      //--------------------------------------------------------------------------
      //
      //  Event Handlers
      //
      //--------------------------------------------------------------------------
      onFieldChange: function () {},
      onItemSelected: function () {},
      onSave: function () {}

    });
    lang.mixin(FormBuilder, {
      STRING_FIELD_OPTION_RICHTEXT: "richtext",
      STRING_FIELD_OPTION_TEXTAREA: "textarea",
      STRING_FIELD_OPTION_TEXTBOX: "textbox"
    });
    return FormBuilder;
  });