<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>IdentifyTask - 4.12</title>

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      .esri-popup .esri-popup-header .esri-title {
        font-size: 18px;
        font-weight: bolder;
      }

      .esri-popup .esri-popup-body .esri-popup-content {
        font-size: 14px;
      }
    </style>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.12/esri/themes/light/main.css"
    />
    <script src="https://js.arcgis.com/4.12/"></script>

    <script>
      require([
        "esri/Map",
        "esri/views/MapView",
        "esri/layers/TileLayer",
        "esri/tasks/IdentifyTask",
        "esri/layers/GraphicsLayer",
        "esri/tasks/support/IdentifyParameters",
        "esri/tasks/Geoprocessor",
        "esri/symbols/SimpleLineSymbol",
        "esri/symbols/SimpleMarkerSymbol",
        "esri/symbols/SimpleFillSymbol",
        "esri/Graphic",
        "esri/tasks/support/FeatureSet",
        "esri/layers/FeatureLayer",
        "esri/geometry/Polyline",
        "esri/layers/ElevationLayer",
        "esri/core/promiseUtils",
        "esri/geometry/Multipoint"
      ], function(Map, MapView,
        TileLayer, IdentifyTask,
        GraphicsLayer,IdentifyParameters,Geoprocessor,
      SimpleLineSymbol,SimpleMarkerSymbol,SimpleFillSymbol,
    Graphic,FeatureSet,FeatureLayer,Polyline,ElevationLayer,promiseUtils,Multipoint) {

        var identifyTask, params;

        // URL to the map service where the identify will be performed
        var soilURL =
          "https://services.arcgisonline.com/arcgis/rest/services/Specialty/Soil_Survey_Map/MapServer";
        var waterURL = "https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer";
        // Add the map service as a TileLayer for fast rendering
        // Tile layers are composed of non-interactive images. For that reason we'll
        // use IdentifyTask to query the service to add interactivity to the app
        var parcelsLayer = new TileLayer({
          url: soilURL,
          opacity: 0.5
        });


        var map = new Map({
          basemap: "topo"//"osm"
        });
        //map.add(parcelsLayer);


        var waterlayer=new FeatureLayer({
          url: waterURL,
          opacity: 0.5
        });
        map.add(waterlayer);
        //var overlay = new TileLayer("http://hydrology.esri.com/arcgis/rest/services/WorldHydroReferenceOverlay/MapServer");
        //map.add(overlay);
        var elevLyr = new ElevationLayer({
          // Custom elevation service
          url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/"//"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Elevation/MtBaldy_Elevation/ImageServer"
        });

        var watersheds = new GraphicsLayer();

        map.add(watersheds);

        var tempPoint = new GraphicsLayer();
        map.add(tempPoint);

        var view = new MapView({
          map: map,
          container: "viewDiv",
          center: [-80.98813, 37.030508],
          zoom: 15
        });
/* show the water boundary
        view.whenLayerView(waterlayer).then(function(layerView){
          layerView.watch("updating", function(val){
            if(!val){  // wait for the layer view to finish updating
              layerView.queryFeatures().then(function(results){
                console.log(results);  // prints all the client-side features to the console

              });
            }
          });
        });
*/
        view.when(function() {
          // executeIdentifyTask() is called each time the view is clicked
          //view.on("click", executeIdentifyTask);
          //view.on("click", computeWatershed);
          // Create identify task for the specified map service
          view.on("click", Elevation);
          identifyTask = new IdentifyTask(soilURL);

          // Set the parameters for the Identify
          params = new IdentifyParameters();
          params.tolerance = 3;
          params.layerIds = [0, 1, 2];
          params.layerOption = "top";
          params.width = view.width;
          params.height = view.height;
        });

        function Elevation(event){
          var position = event.mapPoint;
          var tpoly=new Polyline({
            paths: [[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax],[view.extent.xmax,view.extent.ymin],[view.extent.xmin,view.extent.ymin]],
            spatialReference: view.spatialReference
          });
          var tmulpt=new Multipoint({
             points:[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
             spatialReference:view.spatialReference
           });
          var queryBeforeLandslide = elevLyr.queryElevation(
            tmulpt
          );
          console.log(tmulpt);
          promiseUtils
            .eachAlways([queryBeforeLandslide])
            .then(function(results) {
              console.log(results[0].value.points[0][2]);
              //console.log(position);
              //console.log( results[0].value.geometry.z);
            });

        }
        //Set GP Symbology
        var outline = new SimpleLineSymbol({
          cap:"round",
          color: [0,0,0,1],
          join:"round"
        });

        var pointSymbol = new SimpleMarkerSymbol({
          color:[59, 148, 0, 1],
          size: "10",
          style:"circle",
          outline:outline
        });

        var polySymbol = new SimpleFillSymbol({
          color:[55,138,73,.25],
          outline: outline
        });
        //Add Watershed Delineation Geoprocessing Function
        gp = new Geoprocessor({
          url: "http://hydro.arcgis.com/arcgis/rest/services/Tools/Hydrology/GPServer/Watershed",
          spatialReference: { wkid: 102100  }
        });


        function computeWatershed(evt) {
                    var graphic = new Graphic(evt.mapPoint, pointSymbol);
                    tempPoint.add(graphic);
                    //window.setTimeout(function(){tempPoint.clear()}, 350);

                    var features = [];
                    features.push(graphic);
                    var featureSet = new FeatureSet();
                    featureSet.features = features;

                    var params = {
                      "InputPoints": featureSet,
                      "SnapDistance": "5000",
                      "SnapDistanceUnits": "Meters",
                      "SourceDatabase": "FINEST",
                      "Generalize": "True"
                    };
                    console.log("here");
                    gp.submitJob(params, Callback, function(error){
                    console.log("error", error, params);
                    window.alert("Sorry, we do not have data for this region at your requested resolution");
                    });
                  }
                  function Callback(jobInfo){
                      gp.getResultData(jobInfo.jobId, "WatershedArea", drawWatershed);
                      gp.getResultData(jobInfo.jobId, "SnappedPoints", drawSnappedPoint);
                    }

                    function drawWatershed(results) {
                      console.log(results);
                      var features = results.value.features;
                      for (var f=0, fl=features.length; f<fl; f++) {
                        var feature = features[f];
                        feature.setSymbol(polySymbol);
                        watersheds.add(feature);
                      }
                    }

                    function drawSnappedPoint(results) {
                      console.log(results);
                      tempPoint.clear()
                      var features = results.value.features;
                      for (var f=0, fl=features.length; f<fl; f++) {
                        var feature = features[f];
                        feature.setSymbol(pointSymbol);
                        map.graphics.add(feature);
                      }
                    }


        // Executes each time the view is clicked
        function executeIdentifyTask(event) {
          // Set the geometry to the location of the view click
          params.geometry = event.mapPoint;
          params.mapExtent = view.extent;
          document.getElementById("viewDiv").style.cursor = "wait";

          // This function returns a promise that resolves to an array of features
          // A custom popupTemplate is set for each feature based on the layer it
          // originates from
          identifyTask
            .execute(params)
            .then(function(response) {
              var results = response.results;

              return results.map(function(result) {
                var feature = result.feature;
                var layerName = result.layerName;

                feature.attributes.layerName = layerName;
                if (layerName === "Soil Survey Geographic") {
                  feature.popupTemplate = {
                    // autocasts as new PopupTemplate()
                    title: "{Map Unit Name}",
                    content:
                      "<b>Dominant order:</b> {Dominant Order} ({Dom. Cond. Order %}%)" +
                      "<br><b>Dominant sub-order:</b> {Dominant Sub-Order} ({Dom. Cond. Suborder %}%)" +
                      "<br><b>Dominant Drainage Class:</b> {Dom. Cond. Drainage Class} ({Dom. Cond. Drainage Class %}%)" +
                      "<br><b>Farmland Class:</b> {Farmland Class}"
                  };
                } else if (layerName === "State Soil Geographic") {
                  feature.popupTemplate = {
                    // autocasts as new PopupTemplate()
                    title: "{Map Unit Name}",
                    content:
                      "<b>Dominant order:</b> {Dominant Order} ({Dominant %}%)" +
                      "<br><b>Dominant sub-order:</b> {Dominant Sub-Order} ({Dominant Sub-Order %}%)"
                  };
                } else if (layerName === "Global Soil Regions") {
                  feature.popupTemplate = {
                    // autocasts as new PopupTemplate()
                    title: layerName,
                    content:
                      "<b>Dominant order:</b> {Dominant Order}" +
                      "<br><b>Dominant sub-order:</b> {Dominant Sub-Order}"
                  };
                }
                return feature;
              });
            })
            .then(showPopup); // Send the array of features to showPopup()


          // Shows the results of the Identify in a popup once the promise is resolved
          function showPopup(response) {
            if (response.length > 0) {
              view.popup.open({
                features: response,
                location: event.mapPoint
              });
            }
            document.getElementById("viewDiv").style.cursor = "auto";
          }
        }
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
  </body>
</html>
